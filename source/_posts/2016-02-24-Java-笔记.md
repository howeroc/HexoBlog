title: Java 笔记
date: 2016-02-24 01:35:55
tags:
---
#### 并发（Concurrency）与并行（Parallelism）的区别：
> 并发是逻辑上的的同步
> 并行是物理上同时发生
	
#### 虚函数

> 在Java语言中, 所有的方法默认都是"虚函数". 
> 只有以关键字 final 标记的方法才是非虚函数.

<!-- more -->
#### 覆盖（重写overide）、重载（overload）与隐藏（hide）的区别
- 覆盖

	> 覆盖是指派生类中重新对基类中的虚函数（注意是虚函数）重新实现。
	> 即函数名和参数都一样只是函数的实现体不一样
	>
	> 子类实例方法不能覆盖父类的静态方法；子类的静态方法也不能覆盖父类的实例方法(编译时报错)，总结为方法不能交叉覆盖

- 重载
	
	> 不同的函数使用相同的函数名，但参数个数,类型顺序或类型不同
	>
	> 返回值和异常以及访问修饰符，不能作为重载的条件(因为对于匿名调用，会出现歧义，eg:void a ()和int a() ，如果调用a()，出现歧义)

- 隐藏(只发生在子类和父类有同名的静态方法)

	> 隐藏：父类和子类拥有相同名字的属性或者方法时，父类的同名的属性或者方法形式上不见了，实际是还是存在的
	>
	> 注意：当发生隐藏的时候，声明类型是什么类，就调用对应类的属性或者方法，而不会发生动态绑定
	> 
	> 方法隐藏只有一种形式，就是父类和子类存在相同的静态方法
	> 属性只能被隐藏，不能被覆盖
	> 子类实例变量/静态变量可以隐藏父类的实例/静态变量，总结为变量可以交叉隐藏
	
**注意：**

> 隐藏和覆盖的区别：
>
> - 被隐藏的属性，在子类被强制转换成父类后，访问的是父类中的属性
> - 被覆盖的方法，在子类被强制转换成父类后，调用的还是子类自身的方法
> - 因为覆盖是动态绑定，是受RTTI(run time type identification，运行时类型检查)约束的，隐藏不受RTTI约束，总结为RTTI只针对覆盖，不针对隐藏
	
**特殊情况：**
	
> 1. final修饰的属性可以被隐藏，但是不能被赋值，即不能用=来赋值，网上说final属性不能被修改，这个说法不准确，因为对于引用类型的变量用final修饰后，它只是不能被指向其他对象，但是可以改它自身的值，可以用ArrayList测试，final属性可以在运行的时候进行初始化，但是不能不出现初始化语句
> 2. final修饰的方法不能被覆盖，可以被重载
> 3. final修饰的类不能被继承
> 4. private 方法隐式添加了final

#### 面向对象编程的五个特性

- 封装

	> 封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。
	
	>下面列出了使用封装的一些好处：

	> - 通过隐藏对象的属性来保护对象内部的状态。
	> - 提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。
	> - 禁止对象之间的不良交互提高模块化。
	
- 多态
- 继承
- 抽象

#### 线程

- 创建线程的三种方式

	> - 继承Tread类
	> - 实现Runable接口
	> - 使用Executor框架创建线程池
	
- 线程的几种状态

	> 1. Runable（就绪）：线程准备运行，但不一定能马上运行
	> 2. Runing（运行中）：进程正在执行线程的代码
	> 3. Waiting（等待中）：线程处于阻塞状态，等待外部处理结束
	> 4. Sleeping（睡眠中）：线程被强制睡眠
	> 5. Blocked on I/O（I/O阻塞）：等待I/O操作完成
	> 6. Blocked on Synchronization（同步阻塞）：等待获取锁
	> 7. Dead（死亡）：线程执行结束

- 同步方法和同步代码块的区别

	> 在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在***方法级别***(粗粒度锁)或者是***代码块级别***(细粒度锁)。
	
- 避免线程死锁的方法
	
	> [银行家算法](https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95)

#### Cloneable和Serializable接口

- [对象的克隆](http://blog.csdn.net/kenthong/article/details/5758884)
- [序列化](http://blog.csdn.net/initphp/article/details/8277907)

#### Java集合类框架的基本接口
- Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。最基本的接口有：
	
	> - Collection：代表一组对象，每一个对象都是它的子元素
	> - Set：不包含重复元素的Collection
	> - List：有顺序的Collection，并且可以包含重复元素
	> - Map：可以把键（key）映射到值（value）的对象，键不能重复
**注：**
	> 由于集合类的每一种实现类都可以选择自己的方式对元素进行保存和排序，有的允许重复的键有些不允许。故没有实现Cloneable和Serializable接口
	
### 运算符重载（C++）
运算符重载是多态的一种。这里，运算符（比如+，=，==）被当作多态函数，他们的行为随着其参数类型的不同而不同。运算符并不一定总是符号

运算符重载通常只是一种语法糖（syntactic suger）。它可以简单地通过函数调用来模拟：

```c++
a + b * c
```

在一个支持运算符重载的语言里，上面的写法要比下面的写法有效而简练:

```c++
add(a, multiply(b, c))
```

### 类型转换
在 C 和 C++ 中有时出现数据类型的隐含转换，这就涉及了自动强制类型转换问题。例如，在 C++ 中可将一浮点值赋予整型变量，并去掉其尾数。Java 不支持 C++ 中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。

### 一个`.java`文件可以包含几个类（非内部类）
一个".java"文件可以包含多个类，但只能有一个是public类，并且类名与包名必须相同。

### Java的两种异常类型

- 受检查（checked）异常：必须使用throws语句在方法或者构造函数上声明。
- 不受检查（unchecked）异常：不需要在方法或者构造函数上声明异常，即使方法或者构造函数的执行可能会抛出异，且不受检查的异常可以传播到方法或者是构造函数的外面。

```java
public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, SecurityException, NoSuchFieldException, NoSuchMethodException {  
        // TODO Auto-generated method stub  
          
        //Demo1.  通过Java反射机制得到类的包名和类名  
        Demo1();  
        System.out.println("===============================================");  }
```

### Exception和Error的区别

两者都是Throwable的子类。Excepiton用于用户程序可以捕获的异常情况。Error定义了不期望被用户捕获的异常。

### throw和throws有什么区别

throw用来在程序中明确地抛出异常，相反，throws语句用来表明方法不能处理的异常。

### finally代码块的重要性是什么

无论是否抛出异常，finally代码块总会被执行。就算是没有catch语句同时又抛出异常的情况下，finally代码块仍会被执行。finally代码块主要功能是用来释放资源，比如;I/O缓冲区，数据库链接。

### 异常处理完成后，Exception对象会发生什么变化

Exception发生的对象会在下一个垃圾回收过程中被回收掉。

### finally代码块和finalize()方法有什么区别？

无论是否抛出异常finally代码块始终都会执行，主要是用来释放资源。而finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由jvm来调用的。

### Java反射

反射机制就是可以把一个类,类的成员(函数,属性),当成一个对象来操作。使用反射机制的一些地方

- 工厂模式：Factory类中用反射的话，添加了一个新的类之后，就不需要再修改工厂类了
- 数据库JDBC中通过Class.forName(Driver).来获得数据库链接驱动
- 分析类文件：能够得到类中的方法

	参考：[Java反射机制](http://blog.csdn.net/ljphhj/article/details/12858767)
	
	[Java反射与动态代理](http://www.infoq.com/cn/articles/cf-java-reflection-dynamic-proxy)

### 创建对象的几中方式

1. 用new语句创建对象（最常见）
2. 运用反射手段，调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()方法。
3. 调用clone()方法。
4. 运用反序列化手段调用java.io.ObjectInputStream对象的readObject()方法

	1和2都会明显地调用构造函数;3是在内存中已有对象上复制,所以不会调用构造函数;4是从文件中还原类的对象，也不会调用构造函数

### `==`比较的不是值而是引用
(待编写)

### 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？

不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。


不可以，静态方法只能访问静态成员，因为非静态方法的调用要首先创建对象，因此在调用静态方法时可能对象并没有被初始化 

### 内存中栈（stack）、堆（heap）和静态区（static area）的区别

通常定义一个基本数据类型的变量，一个对象的引用，还有函数调用现场的保存都使用内存中的栈空间；而通过new关键字和构造函数创建的对象存储在堆空间；程序中的字面量（literal）如直接书写的100、"hell"和常量都是放在静态区中。栈的空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。

```java
String str = new String("hello");
```

上例中变量str放在栈上，new创建出的对象放在堆上，而“hello”存在静态区中。

> **补充：**较新版本的Java（从Java 6的某个更新开始）中使用了一项叫“逃逸分析”的技术，可以将一些局部对象放在栈上以提升对象的操作性能。

### 内部类是否可以引用它的包含类（外部类）的成员，有什么限制

一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员

### 构建器（Constructor）是否可被Override

构造器不能被继承，因此不能重写，但可以被重载。

